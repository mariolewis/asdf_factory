import logging
import json
from PySide6.QtWidgets import QWidget, QMessageBox, QHeaderView, QAbstractItemView
from PySide6.QtGui import QStandardItemModel, QStandardItem
from PySide6.QtCore import Signal, Qt

# This import is generated by the uic command you just ran
from gui.ui_backlog_ratification_page import Ui_BacklogRatificationPage
from master_orchestrator import MasterOrchestrator

class BacklogRatificationPage(QWidget):
    """
    The logic handler for the new Backlog Ratification page.
    """
    backlog_ratified = Signal(list)

    def __init__(self, orchestrator: MasterOrchestrator, parent=None):
        super().__init__(parent)
        self.orchestrator = orchestrator
        self.ui = Ui_BacklogRatificationPage()
        self.ui.setupUi(self)

        self.model = QStandardItemModel(self)
        self.ui.backlogTableView.setModel(self.model)
        self._configure_table()
        self.connect_signals()

    def _configure_table(self):
        """Sets the table headers and column resizing behavior."""
        self.ui.backlogTableView.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.model.setHorizontalHeaderLabels(['Title', 'Description', 'Priority', 'Complexity'])
        header = self.ui.backlogTableView.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        self.ui.backlogTableView.setColumnWidth(0, 250)

    def prepare_for_display(self):
        """
        Loads the AI-generated backlog items from the orchestrator and populates the table.
        """
        self.model.clear()
        self._configure_table() # Re-apply headers after clearing

        task = self.orchestrator.task_awaiting_approval or {}
        items_json_str = task.get("generated_backlog_items", "[]")

        try:
            items = json.loads(items_json_str)
            if isinstance(items, list) and len(items) > 0 and items[0].get("error"):
                error_details = items[0].get("details", "No details provided.")
                QMessageBox.critical(self, "Generation Failed", f"The AI failed to generate backlog items:\n{error_details}")
                return

            for item in items:
                title_item = QStandardItem(item.get('title', ''))
                desc_item = QStandardItem(item.get('description', ''))
                priority_item = QStandardItem(item.get('priority', 'Medium'))
                complexity_item = QStandardItem(item.get('complexity', 'Medium'))
                self.model.appendRow([title_item, desc_item, priority_item, complexity_item])

        except (json.JSONDecodeError, TypeError):
            QMessageBox.critical(self, "Error", f"Failed to parse the generated backlog items. The format is invalid.\n\nContent: {items_json_str}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An unexpected error occurred while preparing the display: {e}")

    def connect_signals(self):
        """Connects the page's buttons to their handler methods."""
        self.model.rowsInserted.connect(self.on_rows_inserted)
        self.ui.addItemButton.clicked.connect(self.on_add_item_clicked)
        self.ui.deleteItemButton.clicked.connect(self.on_delete_item_clicked)
        self.ui.ratifyButton.clicked.connect(self.on_ratify_clicked)

    def on_add_item_clicked(self):
        """Adds a new, empty row to the table for the user to fill in."""
        self.model.appendRow([
            QStandardItem("New Item Title"),
            QStandardItem("New item description."),
            QStandardItem("Medium"),
            QStandardItem("Medium")
        ])

    def on_rows_inserted(self, parent, first, last):
        """Scrolls the view to the newly added row."""
        self.ui.backlogTableView.scrollToBottom()

    def on_delete_item_clicked(self):
        """Deletes the currently selected row from the table."""
        selection_model = self.ui.backlogTableView.selectionModel()
        if not selection_model.hasSelection():
            QMessageBox.warning(self, "No Selection", "Please select an item to delete.")
            return

        reply = QMessageBox.question(self, "Confirm Deletion", "Are you sure you want to delete the selected item?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            selected_row = selection_model.selectedRows()[0]
            self.model.removeRow(selected_row.row())

    def on_ratify_clicked(self):
        """Validates and collects all items from the table, then emits the ratification signal."""
        final_items = []
        for row in range(self.model.rowCount()):
            title = self.model.item(row, 0).text().strip()
            description = self.model.item(row, 1).text().strip()
            priority = self.model.item(row, 2).text().strip()
            complexity = self.model.item(row, 3).text().strip()

            if not title or not description:
                QMessageBox.warning(self, "Validation Error", f"Item in row {row + 1} is missing a title or description.")
                return

            final_items.append({
                "title": title,
                "description": description,
                "priority": priority,
                "complexity": complexity
            })

        if not final_items:
            QMessageBox.warning(self, "Empty Backlog", "Cannot ratify an empty backlog. Please add at least one item.")
            return

        self.backlog_ratified.emit(final_items)